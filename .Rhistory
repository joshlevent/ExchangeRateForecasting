timestamp <- format(Sys.time(), "%Y%m%d-%H%M%S")
filename <- paste0("../cache/USPolicy-", timestamp, ".csv")
write(data, file = filename)
# parse the file contents and save to objects
df <- read_csv(data, skip = 1, col_types = "Dd", col_names = c("Date", "Value"))
USPolicyRate <- xts(df$Value, order.by = df$Date)
# transformations to select policy changes
USPolicyChange <- ts_diff(USPolicyRate)
USPolicyChange <- subset(USPolicyChange, value != 0)
# 1.6 Combining and trimming exchange rate and interest rate timeseries
# Select and rename relevant columns
SARONData <- SARONData %>% select(Date, SARON = Value)
SOFRData <- SOFRData %>% select(Date, SOFR = Value)
ERData <- ERData %>% select(Date, LogDifferenceCHFUSD, LogCHFUSD, CHFUSD)
# Combine dataframes
combinedData <- reduce(list(SARONData, SOFRData, ERData), full_join, by = "Date")
# Identify valid date range
first_valid_date <- combinedData %>% filter(!is.na(SARON) & !is.na(SOFR) & !is.na(LogDifferenceCHFUSD)) %>% summarize(first_date = min(Date)) %>% pull(first_date)
last_valid_date <- combinedData %>% filter(!is.na(SARON) & !is.na(SOFR) & !is.na(LogDifferenceCHFUSD)) %>% summarize(last_date = max(Date)) %>% pull(last_date)
# Trim data to valid range
trimmedData <- combinedData %>% filter(Date >= first_valid_date & Date <= last_valid_date)
# checking whether the log difference approximation is suitable
max(trimmedData$LogDifferenceCHFUSD, na.rm = TRUE)
min(trimmedData$LogDifferenceCHFUSD, na.rm = TRUE)
# Calculate the interest rate differential
# this is i^CH - i^US
trimmedData <- trimmedData %>%
mutate(IRd = SARON - SOFR)
# split data into timeseries objects
IRd <- xts(trimmedData$IRd, order.by = trimmedData$Date)
ERd <- xts(trimmedData$LogDifferenceCHFUSD, order.by = trimmedData$Date)
# check for stationarity with u Root test
uRootER <- CADFtest(ERd, max.lag.y = 10, type = "drift", criterion = "BIC")
summary(uRootER)
# this is stationary, good!
uRootIRd <- CADFtest(IRd, max.lag.y = 10, type = "drift", criterion = "BIC")
summary(uRootIRd)
# this is not stationary, bad!
# create a first difference variable
# this is IRd_t - IRd_t-1 (lag 1)
IRdd <- IRd - stats::lag(IRd)
# check the first difference for
uRootFDIR <- CADFtest(IRdd, max.lag.y = 10, type = "drift", criterion = "BIC")
summary(uRootFDIR)
# plot first difference of interest rate differential
ts_plot(IRdd)
p <- autoplot(IRdd)
p <- ggLayout(p) +
labs(title = "First differences of Interest Rate differential between Switzerland and USA") +
scale_y_continuous(breaks = seq(-3, 3, by = 0.5)) +
theme(panel.grid.minor.x = element_line(colour = "black",linewidth=0.1,linetype="dotted"))
p
ggsave(paste(outDir, "First_diff_interest_rate_differential.pdf", sep = "/"), plot = last_plot(), width = 21, height = 14.8, units = c("cm"))
# plot first difference of interest rate differential
ts_plot(IRdd)
p <- autoplot(IRdd)
p <- ggLayout(p) +
labs(title = "First differences of Interest Rate differential between Switzerland and USA") +
scale_y_continuous(breaks = seq(-3, 3, by = 0.5)) +
theme(panel.grid.minor.x = element_line(colour = "black",linewidth=0.1,linetype="dotted"))
p
ggsave(paste(outDir, "First_diff_interest_rate_differential.pdf", sep = "/"), plot = last_plot(), width = 21, height = 14.8, units = c("cm"))
# plot first difference of log exchange rates
ts_plot(ERd)
p <- autoplot(ERd)
p <- ggLayout(p) +
labs(title = "First differences of log exchange rate between Switzerland and USA") +
scale_y_continuous(breaks = seq(-3, 3, by = 0.5)) +
theme(panel.grid.minor.x = element_line(colour = "black",linewidth=0.1,linetype="dotted"))
p
ggsave(paste(outDir, "First_diff_log_exchange_rate.pdf", sep = "/"), plot = last_plot(), width = 21, height = 14.8, units = c("cm"))
# plot both the interest rates
InterestRatesLong <- pivot_longer(trimmedData, cols = c(SARON, SOFR), names_to = "id", values_to = "value")
InterestRatesLong <- select(InterestRatesLong, Date, id, value)
ts_plot(InterestRatesLong)
p <- ggplot(InterestRatesLong, aes(x = Date, y = value, color = id)) +
geom_line()
p <- ggLayout(p) +
labs(title = "Swiss and US Interest Rates (Secured Overnight) Over Time") +
scale_color_manual(values = c("SARON" = "firebrick4", "SOFR" = "blue4"),
labels = c("SARON" = "Switzerland", "SOFR" = "United States")) +
scale_y_continuous(breaks = seq(-1, 5.5, by = 0.5)) +
theme(panel.grid.minor.x = element_line(colour = "black",linewidth=0.1,linetype="dotted"))
p
ggsave(paste(outDir, "InterestRates.pdf", sep = "/"), plot = last_plot(), width = 21, height = 14.8, units = c("cm"))
p <- plotACF(ERd, 365)
p <- ggLayout(p) +
labs(title = "Autocorrelation Function of first differences of log exchange rate")
p
ggsave(paste(outDir, "ACFExchangeRateDiff.pdf", sep = "/"), plot = last_plot(), width = 21, height = 14.8, units = c("cm"))
plotACF(IRdd, 365)
ggsave(paste(outDir, "ACFInterestRateDiff.pdf", sep = "/"), plot = last_plot(), width = 21, height = 14.8, units = c("cm"))
p <- plotCCF(ERd, IRdd, lag.max = 365)
p <- ggLayout(p) +
labs(title = "Cross Correlation Function of Interest Rate differential and Exchange Rate")
p
ggsave(paste(outDir, "CCF.pdf", sep = "/"), plot = last_plot(), width = 21, height = 14.8, units = c("cm"))
# Perform simple regression analysis
# THIS IS AN IN-SAMPLE TEST (BEST CASE)
result <- lm(ERd ~ IRdd)
summary(result)
# calculate error measures for empirical model
EmpiricalError = ts(result$residuals)
ME2 = mean(EmpiricalError)
T=length(EmpiricalError)
FEV2 = var(EmpiricalError)*(T-1)/T
MSFE2 = mean(EmpiricalError^2)
RMSFE2 = sqrt(MSFE2)
MAFE2 = mean(abs(EmpiricalError))
# Create forecast with theoretical model
trimmedData$TheoryForecast = dplyr::lag(trimmedData$IRd/365 + trimmedData$LogCHFUSD)
trimmedData$TheoryCHFUSD = exp(trimmedData$TheoryForecast/100)
CHFUSD = xts(trimmedData$CHFUSD, order.by = trimmedData$Date)
TheoryCHFUSD = xts(trimmedData$TheoryCHFUSD, order.by = trimmedData$Date)
ts_plot(CHFUSD, TheoryCHFUSD)
# calculate error measures for theoretical model
trimmedData$TheoryError = trimmedData$LogCHFUSD - trimmedData$TheoryForecast
TheoryError = xts(trimmedData$TheoryError, order.by = trimmedData$Date)
TheoryError <- na.trim(TheoryError)
ts_plot(TheoryError)
ME1 = mean(TheoryError)
T=length(TheoryError)
FEV1 = var(TheoryError)*(T-1)/T
MSFE1 = mean(TheoryError^2)
RMSFE1 = sqrt(MSFE1)
MAFE1 = mean(abs(TheoryError))
# Fit ARIMA model for benchmark
arima_model <- auto.arima(ERd, stepwise=TRUE, approximation=TRUE, ic = c("aic"))
pdf("arima.pdf", width = 11.7, height = 8.3)
summary(arima_model)
# ------------------------------------------------------------------------------
#   5) Narrow sample
# ------------------------------------------------------------------------------
# combine US and Swiss policy changes
AllPolicyChange = rbind(USPolicyChange,SwissPolicyChange)
# extract the dates from the time series object
dates <- as.Date(time(AllPolicyChange))
# restrict the range to our sample range
dates <- dates[dates >= first_valid_date & dates <= last_valid_date]
# Function to get dates 2 days before and after a given date
expand_dates <- function(date) {
seq(from = date - 2, to = date + 2, by = "days")
}
# Apply the function to each date and create a vector of all relevant dates
expanded_dates <- unique(unlist(lapply(dates, expand_dates)))
filteredData <- trimmedData[trimmedData$Date %in% expanded_dates, ]
IRd_narrow = xts(filteredData$IRd, order.by = filteredData$Date)
ERd_narrow = xts(filteredData$LogDifferenceCHFUSD, order.by = filteredData$Date)
result_narrow <- lm(ERd_narrow ~ IRd_narrow)
summary(result_narrow)
# Fit ARIMA model
arima_model_narrow = Arima(ERd_narrow, order = c(1, 0, 0), include.constant= TRUE, method = "ML")
pdf("arima_narrow.pdf", width = 11.7, height = 8.3)
summary(arima_model_narrow)
# Fit ARIMA model
arima_model_narrow = Arima(ERd_narrow, order = c(1, 0, 0), method = "ML")
pdf("arima_narrow.pdf", width = 11.7, height = 8.3)
summary(arima_model_narrow)
# Fit ARIMA model
arima_model_narrow = Arima(ERd_narrow, order = c(1, 0, 0), include.constant= FALSE, method = "ML")
pdf("arima_narrow.pdf", width = 11.7, height = 8.3)
summary(arima_model_narrow)
View(filteredData)
View(trimmedData)
# Perform simple regression analysis
# THIS IS AN IN-SAMPLE TEST (BEST CASE)
result <- lm(ERd ~ IRdd)
summary(result)
# Check autocorrelation of residuals
pdf("residuals.pdf", width = 11.7, height = 8.3)
checkresiduals(result)+theme_minimal()
# Perform simple regression analysis
# THIS IS AN IN-SAMPLE TEST (BEST CASE)
result <- lm(ERd ~ IRdd)
summary(result)
# Check autocorrelation of residuals
pdf("residuals.pdf", width = 11.7, height = 8.3)
checkresiduals(result)+theme_minimal()
dev.off()
View(result)
# Fit ARIMA model
arima_model_narrow = Arima(ERd_narrow, order = c(1, 0, 0), include.constant= FALSE, method = "ML")
result_narrow <- lm(ERd_narrow ~ IRd_narrow)
summary(result_narrow)
# Check autocorrelation of residuals
pdf("residuals_narrow.pdf", width = 11.7, height = 8.3)
checkresiduals(result_narrow)+theme_minimal()
dev.off()
# 1.2 SOFR
# Get data
url <- "https://fred.stlouisfed.org/graph/fredgraph.csv?bgcolor=%23e1e9f0&chart_type=line&drp=0&fo=open%20sans&graph_bgcolor=%23ffffff&height=450&mode=fred&recession_bars=on&txtcolor=%23444444&ts=12&tts=12&width=1319&nt=0&thu=0&trc=0&show_legend=yes&show_axis_titles=yes&show_tooltip=yes&id=SOFR&scale=left&cosd=2018-04-03&coed=2024-11-09&line_color=%234572a7&link_values=false&line_style=solid&mark_type=none&mw=3&lw=2&ost=-99999&oet=99999&mma=0&fml=a&fq=Daily&fam=avg&fgst=lin&fgsnd=2020-02-01&line_index=1&transformation=lin&vintage_date=2024-11-12&revision_date=2024-11-12&nd=2018-04-03"
response <- GET(url)
data <- content(response, "text")
# Save a cache of the data
timestamp <- format(Sys.time(), "%Y%m%d-%H%M%S")
filename <- paste0("../cache/SOFR-", timestamp, ".csv")
write(data, file = filename)
# parse the file contents and save to objects
df <- read_csv(data, skip = 1, col_types = "Dd", col_names = c("Date", "Value"),
na = c("", "ND", "."))
View(df)
setwd("~/Library/CloudStorage/OneDrive-Personal/01 Economics/03 Semester 3 Classes/02 Applied Macroeconometrics/ExchangeRateForecasting")
source("~/Library/CloudStorage/OneDrive-Personal/01 Economics/03 Semester 3 Classes/02 Applied Macroeconometrics/ExchangeRateForecasting/ExchangeRateForecasting.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-Personal/01 Economics/03 Semester 3 Classes/02 Applied Macroeconometrics/ExchangeRateForecasting/ExchangeRateForecasting.R", echo=TRUE)
# Fit ARIMA model for benchmark
arima_model <- Arima(ERd, order = c(1, 0, 0), include.constant= FALSE, method = "ML")
pdf("arima.pdf", width = 11.7, height = 8.3)
summary(arima_model)
dev.off()
ARIMAError = arima_model$residuals
ARIMAError = ts_span(ARIMAError, end = "2067")
ME3 = mean(ARIMAError)
T=length(ARIMAError)
FEV3 = var(ARIMAError)*(T-1)/T
MSFE3 = mean(ARIMAError^2)
RMSFE3 = sqrt(MSFE3)
MAFE3 = mean(abs(ARIMAError))
# add random walk forecast, previous value
trimmedData$RWForecast = dplyr::lag(trimmedData$LogCHFUSD)
trimmedData$RWError = trimmedData$LogCHFUSD - trimmedData$RWForecast
RWError = ts(trimmedData$RWError)
RWError = na.trim(RWError)
ME4 = mean(RWError)
T=length(RWError)
FEV4 = var(RWError)*(T-1)/T
MSFE4 = mean(RWError^2)
RMSFE4 = sqrt(MSFE4)
MAFE4 = mean(abs(RWError))
# draw table of various error measures for all 3 models
Table = c(ME1^2/MSFE1, ME2^2/MSFE2, ME3^2/MSFE3, ME4^2/MSFE4)
Table = rbind(Table, c(FEV1/MSFE1, FEV2/MSFE2, FEV3/MSFE3, FEV4/MSFE4))
Table = rbind(Table, c(RMSFE1, RMSFE2, RMSFE3, RMSFE4))
Table = rbind(Table, c(MAFE1, MAFE2, MAFE3, MAFE4))
Table = round(Table, 2)
colnames(Table) = c("Theoretical", "Empirical", "AR(1)", "Random Walk")
rownames(Table) = c("Share bias", "Share variance", "RMSFE", "MAFE")
Table
save(Table, file = "main_error_table.RData")
# Diebold Mariano test
# a function allows us to test all combinations of a list
dm_test_pairs <- function(error_list) {
if(is.null(names(error_list))) {
stop("Please provide names for the error series in the list.")
}
n <- length(error_list)
results_matrix <- matrix(NA, n, n, dimnames = list(names(error_list), names(error_list)))
for (i in 1:(n-1)) {
for (j in (i+1):n) {
model1_error <- error_list[[i]]
model2_error <- error_list[[j]]
test_result <- dm.test(model1_error, model2_error, h = 1, power = 2)
results_matrix[i, j] <- paste(round(test_result$statistic, 3), " (", round(test_result$p.value, 2), ")", sep = "")
results_matrix[j, i] <- paste(round(test_result$statistic * -1, 3), " (", round(test_result$p.value, 2), ")", sep = "")
}
}
return(results_matrix)
}
errors_list <- list(
Theoretical = TheoryError,
Empirical = EmpiricalError,
"AR(1)"= ARIMAError,
"Random Walk" = RWError
)
dm_test <- dm_test_pairs(errors_list)
dm_test
save(dm_test, file = "dm_test_table.RData")
#  we create a rolling AR(1) Forecast as a baseline
ER <- ts_span(ER, start = "2018-01-01")
# ------------------------------------------------------------------------------
#   5) Narrow sample
# ------------------------------------------------------------------------------
# combine US and Swiss policy changes
AllPolicyChange = rbind(USPolicyChange,SwissPolicyChange)
# extract the dates from the time series object
dates <- as.Date(time(AllPolicyChange))
# restrict the range to our sample range
dates <- dates[dates >= first_valid_date & dates <= last_valid_date]
# Function to get dates 2 days before and after a given date
expand_dates <- function(date) {
seq(from = date - 2, to = date + 2, by = "days")
}
# Apply the function to each date and create a vector of all relevant dates
expanded_dates <- unique(unlist(lapply(dates, expand_dates)))
filteredData <- trimmedData[trimmedData$Date %in% expanded_dates, ]
IRd_narrow = xts(filteredData$IRd, order.by = filteredData$Date)
ERd_narrow = xts(filteredData$LogDifferenceCHFUSD, order.by = filteredData$Date)
result_narrow <- lm(ERd_narrow ~ IRd_narrow)
summary(result_narrow)
# Check autocorrelation of residuals
pdf("residuals_narrow.pdf", width = 11.7, height = 8.3)
checkresiduals(result_narrow)+theme_minimal()
dev.off()
# Fit ARIMA model
arima_model_narrow = Arima(ERd_narrow, order = c(1, 0, 0), include.constant= FALSE, method = "ML")
pdf("arima_narrow.pdf", width = 11.7, height = 8.3)
summary(arima_model_narrow)
checkresiduals(arima_model_narrow)
forecast <- forecast(arima_model_narrow, h = 365)
plot(forecast)
dev.off()
arima_narrow_error = arima_model_narrow$residuals
rw_narrow_error = ts(filteredData$RWError)
theory_narrow_error = ts(filteredData$TheoryError)
empirical_narrow_error = ts(result_narrow$residuals)
calculate_error_measures <- function(error_series_list) {
# Check if the list has names
if(is.null(names(error_series_list))) {
stop("Please provide names for the error series in the list.")
}
# Initialize a list to store calculated measures for each error series
measures_list <- list()
for (error_series_name in names(error_series_list)) {
error_series <- error_series_list[[error_series_name]]
T <- length(error_series)
ME <- mean(error_series)
FEV <- var(error_series) * (T - 1) / T
MSFE <- mean(error_series^2)
RMSFE <- sqrt(MSFE)
MAFE <- mean(abs(error_series))
# Compute Share Bias and Share Variance
ShareBias <- ME^2 / MSFE
ShareVariance <- FEV / MSFE
# Store the measures in the list
measures_list[[error_series_name]] <- c(ShareBias, ShareVariance, RMSFE, MAFE)
}
# Convert the list to a data frame
error_table <- do.call(cbind, measures_list)
# Set column and row names
rownames(error_table) <- c("Share bias", "Share variance", "RMSFE", "MAFE")
# Round the table values
return(round(error_table, 2))
}
error_series_list <- list(
Theoretical = theory_narrow_error,
Empirical = empirical_narrow_error,
"AR(1)"= arima_narrow_error,
"Random Walk" = rw_narrow_error
)
error_table <- calculate_error_measures(error_series_list)
print(error_table)
save(error_table, file = "narrow_error_table.RData")
narrow_dm_test <- dm_test_pairs(error_series_list)
narrow_dm_test
save(narrow_dm_test, file = "narrow_dm_test_table.RData")
# Create forecast with theoretical model
trimmedData$DailyRate <- (1 + trimmedData$IRd / 100)^(1/365) - 1
trimmedData$TheoryForecast = dplyr::lag(trimmedData$DailyRate + trimmedData$LogCHFUSD)
trimmedData$TheoryCHFUSD = exp(trimmedData$TheoryForecast/100)
CHFUSD = xts(trimmedData$CHFUSD, order.by = trimmedData$Date)
TheoryCHFUSD = xts(trimmedData$TheoryCHFUSD, order.by = trimmedData$Date)
ts_plot(CHFUSD, TheoryCHFUSD)
# as before we use the IRdd for the estimated model
IRdd_narrow <- IRd_narrow - stats::lag(IRd_narrow)
result_narrow <- lm(ERd_narrow ~ IRdd_narrow)
summary(result_narrow)
# p-value of 0.86 - not significant
save(result_narrow, file = "narrow_empirical_results.RData")
? table()
narrow_empirical_results <- summary(result_narrow)
narrow_empirical_results
# p-value of 0.86 - not significant
save(narrow_empirical_results, file = "narrow_empirical_results.RData")
narrow_empirical_results
# p-value of 0.86 - not significant
table(narrow_empirical_results)
? summary
View(result_narrow)
View(narrow_empirical_results)
narrow_empirical_results[["coefficients"]]
# p-value of 0.86 - not significant
table(narrow_empirical_results[["coefficients"]])
save(narrow_empirical_results[["coefficients"]], file = "narrow_empirical_results.RData")
narrow_empirical_results[["coefficients"]]
table(narrow_empirical_results[["coefficients"]])
source("~/Library/CloudStorage/OneDrive-Personal/01 Economics/03 Semester 3 Classes/02 Applied Macroeconometrics/ExchangeRateForecasting/ExchangeRateForecasting.R", echo=TRUE)
# Fit ARIMA model for benchmark
arima_model <- Arima(ERd, order = c(1, 0, 0), include.constant= FALSE, method = "ML")
pdf("arima.pdf", width = 11.7, height = 8.3)
summary(arima_model)
checkresiduals(arima_model)
forecast <- forecast(arima_model, h = 365)
plot(forecast)
dev.off()
View(arima_model)
View(result)
View(arima_model)
? list()
# Check residuals of theoretical model
TheoryList = list(residuals = TheoryError)
View(TheoryList)
checkresiduals(TheoryList)+theme_minimal()
pdf("theoretical_residuals.pdf", width = 11.7, height = 8.3)
checkresiduals(TheoryList)+theme_minimal()
dev.off()
source("~/Library/CloudStorage/OneDrive-Personal/01 Economics/03 Semester 3 Classes/02 Applied Macroeconometrics/ExchangeRateForecasting/ExchangeRateForecasting.R", echo=TRUE)
setwd("~/Library/CloudStorage/OneDrive-Personal/01 Economics/03 Semester 3 Classes/02 Applied Macroeconometrics/ExchangeRateForecasting")
source("~/Library/CloudStorage/OneDrive-Personal/01 Economics/03 Semester 3 Classes/02 Applied Macroeconometrics/ExchangeRateForecasting/ExchangeRateForecasting.R", echo=TRUE)
View(result_narrow)
View(filteredData)
View(result_narrow)
View(IRdd_narrow)
trimmedData$IRdd = trimmedData$IRd - dyplr::lag(trimmedData$IRd)
trimmedData$IRdd = trimmedData$IRd - dplyr::lag(trimmedData$IRd)
View(trimmedData)
filteredData <- trimmedData[trimmedData$Date %in% expanded_dates, ]
View(filteredData)
IRd_narrow = xts(filteredData$IRd, order.by = filteredData$Date)
# as before we use the IRdd for the estimated model
IRdd_narrow <- xts(filteredData$IRdd, order.by = filteredData$Date)
ERd_narrow = xts(filteredData$LogDifferenceCHFUSD, order.by = filteredData$Date)
result_narrow <- lm(ERd_narrow ~ IRdd_narrow)
narrow_empirical_results <- summary(result_narrow)
narrow_empirical_results
checkresiduals(result_narrow)+theme_minimal()
# Check autocorrelation of residuals
pdf("residuals_narrow.pdf", width = 11.7, height = 8.3)
checkresiduals(result_narrow)+theme_minimal()
dev.off()
empirical_narrow_error = ts(result_narrow$residuals)
# combine US and Swiss policy changes
AllPolicyChange = rbind(USPolicyChange,SwissPolicyChange)
# extract the dates from the time series object
dates <- as.Date(time(AllPolicyChange))
# restrict the range to our sample range
dates <- dates[dates >= first_valid_date & dates <= last_valid_date]
# Function to get dates 2 days before and after a given date
expand_dates <- function(date) {
seq(from = date - 2, to = date + 2, by = "days")
}
# Apply the function to each date and create a vector of all relevant dates
expanded_dates <- unique(unlist(lapply(dates, expand_dates)))
trimmedData$IRdd = trimmedData$IRd - dplyr::lag(trimmedData$IRd)
filteredData <- trimmedData[trimmedData$Date %in% expanded_dates, ]
IRd_narrow = xts(filteredData$IRd, order.by = filteredData$Date)
# as before we use the IRdd for the estimated model
IRdd_narrow <- xts(filteredData$IRdd, order.by = filteredData$Date)
ERd_narrow = xts(filteredData$LogDifferenceCHFUSD, order.by = filteredData$Date)
result_narrow <- lm(ERd_narrow ~ IRdd_narrow)
narrow_empirical_results <- summary(result_narrow)
narrow_empirical_results
# p-value of 0.96 - not significant
# save to table if possible
# save(narrow_empirical_results, file = "narrow_empirical_results.RData")
# Check autocorrelation of residuals
pdf("residuals_narrow.pdf", width = 11.7, height = 8.3)
checkresiduals(result_narrow)+theme_minimal()
dev.off()
# this checks for auto-correlation in the residuals, see slide 10 of 1.3.
# Fit ARIMA model
arima_model_narrow = Arima(ERd_narrow, order = c(1, 0, 0), include.constant= FALSE, method = "ML")
pdf("arima_narrow.pdf", width = 11.7, height = 8.3)
summary(arima_model_narrow)
checkresiduals(arima_model_narrow)
forecast <- forecast(arima_model_narrow, h = 365)
plot(forecast)
dev.off()
arima_narrow_error = arima_model_narrow$residuals
rw_narrow_error = ts(filteredData$RWError)
theory_narrow_error = ts(filteredData$TheoryError)
empirical_narrow_error = ts(result_narrow$residuals)
# check residuals for theoretical model
theory_narrow_list = list(residuals = theory_narrow_error)
pdf("theory_residuals_narrow.pdf", width = 11.7, height = 8.3)
checkresiduals(theory_narrow_list)+theme_minimal()
dev.off()
# check residuals for rw model
rw_narrow_list = list(residuals = rw_narrow_error)
pdf("rw_residuals_narrow.pdf", width = 11.7, height = 8.3)
checkresiduals(rw_narrow_list)+theme_minimal()
dev.off()
calculate_error_measures <- function(error_series_list) {
# Check if the list has names
if(is.null(names(error_series_list))) {
stop("Please provide names for the error series in the list.")
}
# Initialize a list to store calculated measures for each error series
measures_list <- list()
for (error_series_name in names(error_series_list)) {
error_series <- error_series_list[[error_series_name]]
T <- length(error_series)
ME <- mean(error_series)
FEV <- var(error_series) * (T - 1) / T
MSFE <- mean(error_series^2)
RMSFE <- sqrt(MSFE)
MAFE <- mean(abs(error_series))
# Compute Share Bias and Share Variance
ShareBias <- ME^2 / MSFE
ShareVariance <- FEV / MSFE
# Store the measures in the list
measures_list[[error_series_name]] <- c(ShareBias, ShareVariance, RMSFE, MAFE)
}
# Convert the list to a data frame
error_table <- do.call(cbind, measures_list)
# Set column and row names
rownames(error_table) <- c("Share bias", "Share variance", "RMSFE", "MAFE")
# Round the table values
return(round(error_table, 2))
}
error_series_list <- list(
Theoretical = theory_narrow_error,
Empirical = empirical_narrow_error,
"AR(1)"= arima_narrow_error,
"Random Walk" = rw_narrow_error
)
error_table <- calculate_error_measures(error_series_list)
print(error_table)
save(error_table, file = "narrow_error_table.RData")
narrow_dm_test <- dm_test_pairs(error_series_list)
narrow_dm_test
save(narrow_dm_test, file = "narrow_dm_test_table.RData")
setwd("~/Library/CloudStorage/OneDrive-Personal/01 Economics/03 Semester 3 Classes/02 Applied Macroeconometrics/ExchangeRateForecasting")
source("~/Library/CloudStorage/OneDrive-Personal/01 Economics/03 Semester 3 Classes/02 Applied Macroeconometrics/ExchangeRateForecasting/ExchangeRateForecasting.R", echo=TRUE)
